# -*- coding: utf-8 -*-
"""
This file defines a Time Signal Generator environment where a signal can be
loaded and played directly to the output devices.  This is perhaps the simplest
control type that might be implemented by the controller, so start here when
designing new control types.

Rattlesnake Vibration Control Software
Copyright (C) 2021  National Technology & Engineering Solutions of Sandia, LLC
(NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
Government retains certain rights in this software.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

from qtpy import QtWidgets,uic,QtCore
from .abstract_environment import AbstractEnvironment,AbstractMetadata,AbstractUI
from .utilities import DataAcquisitionParameters,VerboseMessageQueue,GlobalCommands,rms_time,db2scale
from .ui_utilities import multiline_plotter,load_time_history
from .environments import (ControlTypes,environment_definition_ui_paths,
                           environment_run_ui_paths,
                           )
import netCDF4 as nc4
from multiprocessing.queues import Queue
import numpy as np
import multiprocessing as mp
import copy
import openpyxl

control_type = ControlTypes.TIME
test_level_threshold = 1.01
max_responses_to_plot = 20
max_samples_to_plot = 100000

class TimeQueues:
    """A set of queues used by the Time environment"""
    def __init__(self,
                 environment_command_queue : VerboseMessageQueue,
                 gui_update_queue : mp.queues.Queue,
                 controller_communication_queue : VerboseMessageQueue,
                 data_in_queue : mp.queues.Queue,
                 data_out_queue : mp.queues.Queue,
                 log_file_queue : VerboseMessageQueue
                 ):
        """
        Creates a namespace to store all the queues used by the Time Environment

        Parameters
        ----------
        environment_command_queue : VerboseMessageQueue
            Queue from which the environment will receive instructions.
        gui_update_queue : mp.queues.Queue
            Queue to which the environment will put GUI updates.
        controller_communication_queue : VerboseMessageQueue
            Queue to which the environment will put global contorller instructions.
        data_in_queue : mp.queues.Queue
            Queue from which the environment will receive data from acquisition.
        data_out_queue : mp.queues.Queue
            Queue to which the environment will write data for output.
        log_file_queue : VerboseMessageQueue
            Queue to which the environment will write log file messages.
        """
        self.environment_command_queue = environment_command_queue
        self.gui_update_queue = gui_update_queue
        self.controller_communication_queue = controller_communication_queue
        self.data_in_queue = data_in_queue
        self.data_out_queue = data_out_queue
        self.log_file_queue = log_file_queue

class TimeParameters(AbstractMetadata):
    """Storage container for parameters used by the Time Environment
    """
    def __init__(self,sample_rate,output_signal,cancel_rampdown_time):
        """
        Container to hold signal processing parameters for the Time environment

        Parameters
        ----------
        sample_rate : int
            Number of samples per second that the controller runs.
        output_signal : np.ndarray
            Signal that will be generated by the sources, 2D array (n_outputs x
            n_samples)
        cancel_rampdown_time : float
            Time used to decay the signal to zero if the environment is stopped.
            Prevents "hard stops" from damaging equipment.

        """
        self.sample_rate = sample_rate
        self.output_signal = output_signal
        self.cancel_rampdown_time = cancel_rampdown_time
        
    @property
    def signal_samples(self):
        """The number of samples in the signal"""
        return self.output_signal.shape[-1]
    
    @property
    def output_channels(self):
        """The number of output channels in the signal"""
        return self.output_signal.shape[0]
    
    @property
    def signal_time(self):
        """The length of the signal in seconds"""
        return self.signal_samples/self.sample_rate
    
    @property
    def cancel_rampdown_samples(self):
        """The number of samples required to ramp down the signal when cancelled"""
        return int(self.cancel_rampdown_time*self.sample_rate)

    def store_to_netcdf(self,netcdf_group_handle : nc4._netCDF4.Group):
        """
        Stores parameters to a netCDF group so they can be recovered.

        Parameters
        ----------
        netcdf_group_handle : nc4._netCDF4.Group
            Reference to the netCDF4 group in which the environment data should
            be stored.

        """
        netcdf_group_handle.cancel_rampdown_time = self.cancel_rampdown_time
        # Save the output signal
        netcdf_group_handle.createDimension('output_channels',self.output_channels)
        netcdf_group_handle.createDimension('signal_samples',self.signal_samples)
        var = netcdf_group_handle.createVariable('output_signal','f8',('output_channels','signal_samples'))
        var[...] = self.output_signal
    
    @classmethod
    def from_ui(cls,ui):
        """Creates a TimeParameters object from the user interface

        Parameters
        ----------
        ui : TimeUI
            A Time User Interface

        Returns
        -------
        test_parameters : TimeParameters
            Parameters corresponding to the data in the user interface.

        """
        return cls(sample_rate=ui.definition_widget.output_sample_rate_display.value(),
                    output_signal=ui.signal,
                    cancel_rampdown_time=ui.definition_widget.cancel_rampdown_selector.value())

class TimeUI(AbstractUI):
    """Class defining the user interface for a Random Vibration environment.
    
    This class will contain two main UIs, the environment definition and run.
    The widgets corresponding to these interfaces are stored in TabWidgets in
    the main UI.
    
    This class defines all the call backs and user interface operations required
    for the Time environment."""
    def __init__(self,
                 environment_name : str,
                 definition_tabwidget : QtWidgets.QTabWidget,
                 system_id_tabwidget : QtWidgets.QTabWidget,
                 test_predictions_tabwidget : QtWidgets.QTabWidget,
                 run_tabwidget : QtWidgets.QTabWidget,
                 environment_command_queue : VerboseMessageQueue,
                 controller_communication_queue : VerboseMessageQueue,
                 log_file_queue : Queue):
        """
        Constructs a Time User Interfae
        
        Given the tab widgets from the main interface as well as communication
        queues, this class assembles the user interface components specific to
        the Time Environment

        Parameters
        ----------
        definition_tabwidget : QtWidgets.QTabWidget
            QTabWidget containing the environment subtabs on the Control
            Definition main tab
        system_id_tabwidget : QtWidgets.QTabWidget
            QTabWidget containing the environment subtabs on the System
            Identification main tab.  The Time Environment has no system 
            identification step, so this is not used.
        test_predictions_tabwidget : QtWidgets.QTabWidget
            QTabWidget containing the environment subtabs on the Test Predictions
            main tab.    The Time Environment has no system identification
            step, so this is not used.
        run_tabwidget : QtWidgets.QTabWidget
            QTabWidget containing the environment subtabs on the Run
            main tab.
        environment_command_queue : VerboseMessageQueue
            Queue for sending commands to the Random Vibration Environment
        controller_communication_queue : VerboseMessageQueue
            Queue for sending global commands to the controller
        log_file_queue : Queue
            Queue where log file messages can be written.
    
        """
        super().__init__(environment_name,
             environment_command_queue,controller_communication_queue,log_file_queue)
        # Add the page to the control definition tabwidget
        self.definition_widget = QtWidgets.QWidget()
        uic.loadUi(environment_definition_ui_paths[control_type],self.definition_widget)
        definition_tabwidget.addTab(self.definition_widget,self.environment_name)
        # Add the page to the run tabwidget
        self.run_widget = QtWidgets.QWidget()
        uic.loadUi(environment_run_ui_paths[control_type],self.run_widget)
        run_tabwidget.addTab(self.run_widget,self.environment_name)
        
        # Set up some persistent data
        self.data_acquisition_parameters = None
        self.environment_parameters = None
        self.signal = None
        self.physical_output_names = None
        self.physical_measurement_names = None
        self.show_signal_checkboxes = None
        self.plot_data_items = {}
                
        self.complete_ui()
        self.connect_callbacks()
        
        # Complete the profile commands
        self.command_map['Set Test Level'] = self.change_test_level_from_profile
        self.command_map['Set Repeat'] = self.set_repeat_from_profile
        self.command_map['Set No Repeat'] = self.set_norepeat_from_profile
        
        
    def collect_environment_definition_parameters(self) -> TimeParameters:
        """Collect the parameters from the user interface defining the environment

        Returns
        -------
        TimeParameters
            A metadata or parameters object containing the parameters defining
            the corresponding environment.
        """
        return TimeParameters.from_ui(self)
    
    def complete_ui(self):
        """Helper Function to continue setting up the user interface"""
        # Set common look and feel for plots
        plotWidgets = [self.definition_widget.signal_display_plot,
                       self.run_widget.output_signal_plot,
                       self.run_widget.response_signal_plot]
        for plotWidget in plotWidgets:
            plot_item = plotWidget.getPlotItem()
            plot_item.showGrid(True,True,0.25)
            plot_item.enableAutoRange()
            plot_item.getViewBox().enableAutoRange(enable=True)
            
    def connect_callbacks(self):
        """Helper function to connect callbacks to functions in the class"""
        self.definition_widget.load_signal_button.clicked.connect(self.load_signal)
        self.run_widget.start_test_button.clicked.connect(self.start_control)
        self.run_widget.stop_test_button.clicked.connect(self.stop_control)
    
    def initialize_data_acquisition(self,data_acquisition_parameters : DataAcquisitionParameters):
        """Update the user interface with data acquisition parameters
        
        This function is called when the Data Acquisition parameters are
        initialized.  This function should set up the environment user interface
        accordingly.

        Parameters
        ----------
        data_acquisition_parameters : DataAcquisitionParameters :
            Container containing the data acquisition parameters, including
            channel table and sampling information.

        """
        self.log('Initializing Data Acquisition')
        self.signal = None
        # Get channel information
        channels = data_acquisition_parameters.channel_list
        num_measurements = len([channel for channel in channels if channel.feedback_device is None])
        num_output = len([channel for channel in channels if not channel.feedback_device is None])
        self.physical_output_names = ['{:} {:}{:}'.format('' if channel.channel_type is None 
                                                          else channel.channel_type,channel.node_number,channel.node_direction)
            for channel in channels if channel.feedback_device]
        self.physical_measurement_names = ['{:} {:}{:}'.format('' if channel.channel_type is None
                                                               else channel.channel_type,channel.node_number,channel.node_direction)
            for channel in channels if channel.feedback_device is None]
        # Add rows to the signal table
        self.definition_widget.signal_information_table.setRowCount(num_output)
        self.show_signal_checkboxes = []
        for i,name in enumerate(self.physical_output_names):
            item = QtWidgets.QTableWidgetItem()
            item.setText(name)
            item.setFlags(item.flags() ^ QtCore.Qt.ItemIsEditable)
            self.definition_widget.signal_information_table.setItem(i,1,item)
            checkbox = QtWidgets.QCheckBox()
            checkbox.setChecked(True)
            checkbox.stateChanged.connect(self.show_signal)
            self.show_signal_checkboxes.append(checkbox)
            self.definition_widget.signal_information_table.setCellWidget(i,0,checkbox)
            item = QtWidgets.QTableWidgetItem()
            item.setText('0.0')
            item.setFlags(item.flags() ^ QtCore.Qt.ItemIsEditable)
            self.definition_widget.signal_information_table.setItem(i,2,item)
            item = QtWidgets.QTableWidgetItem()
            item.setText('0.0')
            item.setFlags(item.flags() ^ QtCore.Qt.ItemIsEditable)
            self.definition_widget.signal_information_table.setItem(i,3,item)
        # Fill in the info at the bottom
        self.definition_widget.sample_rate_display.setValue(data_acquisition_parameters.sample_rate)
        self.definition_widget.output_sample_rate_display.setValue(
            data_acquisition_parameters.sample_rate*data_acquisition_parameters.output_oversample)
        self.definition_widget.output_channels_display.setValue(num_output)
            
        # Clear the signal plot
        self.definition_widget.signal_display_plot.getPlotItem().clear()
        self.run_widget.output_signal_plot.getPlotItem().clear()
        self.run_widget.response_signal_plot.getPlotItem().clear()
        
        # Set initial lines
        self.plot_data_items['output_signal_definition'] = multiline_plotter(
                np.arange(2),
                np.zeros((num_output,2)),
                widget=self.definition_widget.signal_display_plot,
                other_pen_options={'width':1},
                names = self.physical_output_names)
        self.plot_data_items['output_signal_measurement'] = multiline_plotter(
                np.arange(2),
                np.zeros((num_output,2)),
                widget=self.run_widget.output_signal_plot,
                other_pen_options={'width':1},
                names = self.physical_output_names)
        self.plot_data_items['response_signal_measurement'] = multiline_plotter(
                np.arange(2),
                np.zeros((num_measurements if num_measurements < max_responses_to_plot else max_responses_to_plot,2)),
                widget=self.run_widget.response_signal_plot,
                other_pen_options={'width':1},
                names = self.physical_measurement_names)
        
        self.data_acquisition_parameters = data_acquisition_parameters
    
    def load_signal(self,clicked,filename=None):
        """Loads a time signal using a dialog or the specified filename

        Parameters
        ----------
        clicked :
            The clicked event that triggered the callback.
        filename :
            File name defining the specification for bypassing the callback when
            loading from a file (Default value = None).

        """
        if filename is None:
            filename,file_filter = QtWidgets.QFileDialog.getOpenFileName(
                self.definition_widget,'Select Signal File',filter='Numpy or Mat (*.npy *.npz *.mat)')
            if filename == '':
                return
        self.definition_widget.signal_file_name_display.setText(filename)
        self.signal = load_time_history(filename,self.definition_widget.output_sample_rate_display.value())
        self.definition_widget.signal_samples_display.setValue(self.signal.shape[-1])
        self.definition_widget.signal_time_display.setValue(self.signal.shape[-1]/
                                                            self.definition_widget.output_sample_rate_display.value())
        maxs = np.max(np.abs(self.signal),axis=-1)
        rmss = rms_time(self.signal,axis=-1)
        for i,(mx,rms) in enumerate(zip(maxs,rmss)):
            self.definition_widget.signal_information_table.item(i,2).setText('{:0.2f}'.format(mx))
            self.definition_widget.signal_information_table.item(i,3).setText('{:0.2f}'.format(rms))
        self.show_signal()
    
    def show_signal(self):
        """Shows the signal on the user interface"""
        for curve,signal,check_box in zip(self.plot_data_items['output_signal_definition'],self.signal,self.show_signal_checkboxes):
            if check_box.isChecked():
                x = np.arange(signal.shape[-1])/self.definition_widget.output_sample_rate_display.value()
                curve.setData(x,signal)
            else:
                curve.setData((0,0),(0,0))
    
    def initialize_environment(self) -> AbstractMetadata:
        """Update the user interface with environment parameters
        
        This function is called when the Environment parameters are initialized.
        This function should set up the user interface accordingly.  It must
        return the parameters class of the environment that inherits from
        AbstractMetadata.

        Returns
        -------
        environment_parameters : TimeParameters
            A TimeParameters object that contains the parameters
            defining the environment.
        """
        self.log('Initializing Environment Parameters')
        data = self.collect_environment_definition_parameters()
        # Make sure everything is defined 
        if data.output_signal is None:
            raise ValueError('Output Signal is not defined!')
        # Initialize the correct sizes of the arrays
        for plot_items in [self.plot_data_items['output_signal_measurement'],self.plot_data_items['response_signal_measurement']]:
            for curve in plot_items:
                curve.setData(np.arange((data.output_signal.shape[-1]//
                                         self.data_acquisition_parameters.output_oversample*2
                                         if data.output_signal.shape[-1]//self.data_acquisition_parameters.output_oversample*2 < max_samples_to_plot
                                         else max_samples_to_plot))/self.data_acquisition_parameters.sample_rate,
                              np.zeros((data.output_signal.shape[-1]//
                                        self.data_acquisition_parameters.output_oversample*2
                                        if data.output_signal.shape[-1]//self.data_acquisition_parameters.output_oversample*2 < max_samples_to_plot
                                        else max_samples_to_plot)))
        self.environment_parameters = data
        return data
        
    def retrieve_metadata(self,netcdf_handle : nc4._netCDF4.Dataset):
        """Collects environment parameters from a netCDF dataset.

        This function retrieves parameters from a netCDF dataset that was written
        by the controller during streaming.  It must populate the widgets
        in the user interface with the proper information.

        This function is the "read" counterpart to the store_to_netcdf 
        function in the TimeParameters class, which will write 
        parameters to the netCDF file to document the metadata.
        
        Note that the entire dataset is passed to this function, so the function
        should collect parameters pertaining to the environment from a Group
        in the dataset sharing the environment's name, e.g.
        
        ``group = netcdf_handle.groups[self.environment_name]``
        ``self.definition_widget.parameter_selector.setValue(group.parameter)``
        
        Parameters
        ----------
        netcdf_handle : nc4._netCDF4.Dataset :
            The netCDF dataset from which the data will be read.  It should have
            a group name with the enviroment's name.
        """
        group = netcdf_handle.groups[self.environment_name]
        self.signal = group.variables['output_signal'][...].data
        self.definition_widget.cancel_rampdown_selector.setValue(group.cancel_rampdown_time)
        maxs = np.max(np.abs(self.signal),axis=-1)
        rmss = rms_time(self.signal,axis=-1)
        for i,(mx,rms) in enumerate(zip(maxs,rmss)):
            self.definition_widget.signal_information_table.item(i,2).setText('{:0.2f}'.format(mx))
            self.definition_widget.signal_information_table.item(i,3).setText('{:0.2f}'.format(rms))
        self.show_signal()
    
    def start_control(self):
        """Starts running the environment"""
        self.run_widget.stop_test_button.setEnabled(True)
        self.run_widget.start_test_button.setEnabled(False)
        self.run_widget.test_level_selector.setEnabled(False)
        self.run_widget.repeat_signal_checkbox.setEnabled(False)
        self.controller_communication_queue.put(self.log_name,(GlobalCommands.START_ENVIRONMENT,self.environment_name))
        self.environment_command_queue.put(self.log_name,(GlobalCommands.START_ENVIRONMENT,
                                                          (db2scale(self.run_widget.test_level_selector.value()),
                                                           self.run_widget.repeat_signal_checkbox.isChecked())))
        self.controller_communication_queue.put(self.log_name,(GlobalCommands.AT_TARGET_LEVEL,self.environment_name))
    
    def stop_control(self):
        """Stops running the environment"""
        self.environment_command_queue.put(self.log_name,(GlobalCommands.STOP_ENVIRONMENT,
                                                          None))
    
    def change_test_level_from_profile(self,test_level):
        """Sets the test level from a profile instruction

        Parameters
        ----------
        test_level :
            Value to set the test level to.
        """
        self.run_widget.test_level_selector.setValue(int(test_level))
        
    
    def set_repeat_from_profile(self,data):
        """Sets the the signal to repeat from a profile instruction

        Parameters
        ----------
        data : Ignored
            Parameter is ignored but required by the ``command_map``

        """
        self.run_widget.repeat_signal_checkbox.setChecked(True)
    
    def set_norepeat_from_profile(self,data):
        """Sets the the signal to not repeat from a profile instruction

        Parameters
        ----------
        data : Ignored
            Parameter is ignored but required by the ``command_map``

        """
        self.run_widget.repeat_signal_checkbox.setChecked(False)
        
    def update_gui(self,queue_data):
        """Update the graphical interface for the environment

        Parameters
        ----------
        queue_data :
            A 2-tuple consisting of ``(message,data)`` pairs where the message
            denotes what to change and the data contains the information needed
            to be displayed.  
        """
        message,data = queue_data
        if message == 'time_data':
            response_data,output_data = data
            for curve,this_data in zip(self.plot_data_items['response_signal_measurement'],response_data):
                x,y = curve.getData()
                y = np.concatenate((y[this_data.size:],this_data[-x.size:]),axis=0)
                curve.setData(x,y)
            # Display the data
            for curve,this_output in zip(self.plot_data_items['output_signal_measurement'],output_data):
                x,y = curve.getData()
                y = np.concatenate((y[this_output.size:],this_output[-x.size:]),axis=0)
                curve.setData(x,y)
        elif message == 'enable':
            widget = None
            for parent in [self.definition_widget,self.run_widget]:
                try:
                    widget = getattr(parent,data)
                    break
                except AttributeError:
                    continue
            if widget is None:
                raise ValueError('Cannot Enable Widget {:}: not found in UI'.format(data))
            widget.setEnabled(True)
        elif message == 'disable':
            widget = None
            for parent in [self.definition_widget,self.run_widget]:
                try:
                    widget = getattr(parent,data)
                    break
                except AttributeError:
                    continue
            if widget is None:
                raise ValueError('Cannot Disable Widget {:}: not found in UI'.format(data))
            widget.setEnabled(False)
        else:
            widget = None
            for parent in [self.definition_widget,self.run_widget]:
                try:
                    widget = getattr(parent,message)
                    break
                except AttributeError:
                    continue
            if widget is None:
                raise ValueError('Cannot Update Widget {:}: not found in UI'.format(message))
            if type(widget) is QtWidgets.QDoubleSpinBox:
                widget.setValue(data)
            elif type(widget) is QtWidgets.QSpinBox:
                widget.setValue(data)
            elif type(widget) is QtWidgets.QLineEdit:
                widget.setText(data)
            elif type(widget) is QtWidgets.QListWidget:
                widget.clear()
                widget.addItems(['{:.3f}'.format(d) for d in data])
                
    @staticmethod
    def create_environment_template(environment_name: str, workbook : openpyxl.workbook.workbook.Workbook):
        """Creates a template worksheet in an Excel workbook defining the
        environment.
        
        This function creates a template worksheet in an Excel workbook that
        when filled out could be read by the controller to re-create the 
        environment.
        
        This function is the "write" counterpart to the 
        ``set_parameters_from_template`` function in the ``TimeUI`` class,
        which reads the values from the template file to populate the user
        interface.

        Parameters
        ----------
        environment_name : str :
            The name of the environment that will specify the worksheet's name
        workbook : openpyxl.workbook.workbook.Workbook :
            A reference to an ``openpyxl`` workbook.

        """
        worksheet = workbook.create_sheet(environment_name)
        worksheet.cell(1,1,'Control Type')
        worksheet.cell(1,2,'Time')
        worksheet.cell(1,4,'Note: Replace cells with hash marks (#) to provide the requested parameters.')
        worksheet.cell(2,1,'Signal File')
        worksheet.cell(2,2,'# Path to the file that contains the time signal that will be output')
        worksheet.cell(3,1,'Cancel Rampdown Time')
        worksheet.cell(3,2,'# Time for the environment to ramp to zero if the environment is cancelled.')
    
    def set_parameters_from_template(self, worksheet : openpyxl.worksheet.worksheet.Worksheet):
        """
        Collects parameters for the user interface from the Excel template file
        
        This function reads a filled out template worksheet to create an
        environment.  Cells on this worksheet contain parameters needed to
        specify the environment, so this function should read those cells and
        update the UI widgets with those parameters.
        
        This function is the "read" counterpart to the 
        ``create_environment_template`` function in the ``TimeUI`` class,
        which writes a template file that can be filled out by a user.
        

        Parameters
        ----------
        worksheet : openpyxl.worksheet.worksheet.Worksheet
            An openpyxl worksheet that contains the environment template.
            Cells on this worksheet should contain the parameters needed for the
            user interface.

        """
        self.load_signal(None,worksheet.cell(2,2).value)
        self.definition_widget.cancel_rampdown_selector.setValue(float(worksheet.cell(3,2).value))

class TimeEnvironment(AbstractEnvironment):
    """Environment defined by a generated time history signal"""
        
    def __init__(self,
                 environment_name : str,
                 queue_container : TimeQueues,
                 acquisition_active : mp.Value,
                 output_active : mp.Value):
        """
        Time History Generation Environment Constructor 
    
        This function fills out the command map and initializes parameters to
        zero or null.

        Parameters
        ----------
        environment_name : str
            Name of the environment.
        queue_container : TimeQueues
            Container of queues used by the Time Environment.

        """
        super().__init__(
                environment_name,
                queue_container.environment_command_queue,
                queue_container.gui_update_queue,
                queue_container.controller_communication_queue,
                queue_container.log_file_queue,
                queue_container.data_in_queue,
                queue_container.data_out_queue,
                acquisition_active,
                output_active)
        self.queue_container = queue_container
        # Define command map
        self.command_map[GlobalCommands.START_ENVIRONMENT] = self.run_environment
        # Persistent data
        self.data_acquisition_parameters = None
        self.environment_parameters = None
        self.startup = True
        self.shutdown_flag = False
        self.current_test_level = 0.0
        self.target_test_level = 0.0
        self.test_level_change = 0.0
        self.repeat = False
        self.signal_remainder = None
        self.output_channels = None
        self.measurement_channels = None
    
    def initialize_data_acquisition_parameters(self,data_acquisition_parameters : DataAcquisitionParameters):
        """Initialize the data acquisition parameters in the environment.
        
        The environment will receive the global data acquisition parameters from
        the controller, and must set itself up accordingly.

        Parameters
        ----------
        data_acquisition_parameters : DataAcquisitionParameters :
            A container containing data acquisition parameters, including
            channels active in the environment as well as sampling parameters.
        """
        self.log('Initializing Data Acquisition Parameters')
        self.data_acquisition_parameters = data_acquisition_parameters
        self.measurement_channels = [index for index,channel in enumerate(self.data_acquisition_parameters.channel_list) if channel.feedback_device is None]
        self.output_channels = [index for index,channel in enumerate(self.data_acquisition_parameters.channel_list) if not channel.feedback_device is None]
    
    def initialize_environment_test_parameters(self,environment_parameters : TimeParameters):
        """
        Initialize the environment parameters specific to this environment
        
        The environment will recieve parameters defining itself from the
        user interface and must set itself up accordingly.

        Parameters
        ----------
        environment_parameters : TimeParameters
            A container containing the parameters defining the environment

        """
        self.log('Initializing Environment Parameters')
        self.environment_parameters = environment_parameters
    
    def run_environment(self,data):
        """Runs the time history environment.
        
        This function handles start up, running, and shutting down the environment
        
        During startup, the function will initialize a buffer that it will
        write from that consists of the output signal.
        
        When running, it will collect data that comes in from the ``data_in_queue``
        and tell the GUI to display it.  This will also tell
        the environment whether or not the signal is the last signal and that
        it should shut down.  The function determines if a
        new signal is required by checking if the data_out_queue is empty.
        If it is empty, we write the next portion of the buffer.
        If the buffer runs dry and the signal is not repeating, it will set the
        last_signal flag which tells the process to begin shutting down.  If
        shutdown is occuring, the process continues to get data until the last
        signal is received.  

        Parameters
        ----------
        data : Tuple
            A tuple containing the test level to run the environment at and
            a boolean specifying whether or not to repeat the signal.

        """
        if self.startup:
            if not data is None:
                self.current_test_level,self.repeat = data
                self.log('Test Level set to {:}'.format(self.current_test_level))
            self.signal_remainder = self.environment_parameters.output_signal
            self.startup = False
        # See if any data has come in
        try:
            acquisition_data,last_acquisition = self.queue_container.data_in_queue.get_nowait()
            measurement_data = acquisition_data[self.measurement_channels]
            output_data = acquisition_data[self.output_channels]
            self.queue_container.gui_update_queue.put((self.environment_name,('time_data',(measurement_data,output_data))))
        except mp.queues.Empty:
            last_acquisition = False
        # See if we need to output data
        if self.queue_container.data_out_queue.empty():
            last_signal = False
            # See if there is enough in the remainder
            if self.data_acquisition_parameters.samples_per_write > self.signal_remainder.shape[-1] and self.repeat:
                self.signal_remainder = np.concatenate((self.signal_remainder,self.environment_parameters.output_signal),axis=-1)
            elif (self.data_acquisition_parameters.samples_per_write >= self.signal_remainder.shape[-1] and not self.repeat) or self.current_test_level == 0.0:
                last_signal = True
            self.output(self.signal_remainder[:,:self.data_acquisition_parameters.samples_per_write], last_signal)
            self.signal_remainder = self.signal_remainder[:,self.data_acquisition_parameters.samples_per_write:]
            if last_signal:
                # Wait until we get the last signal from the acquisition
                while not last_acquisition:
                    self.log('Waiting for Last Acquisition')
                    acquisition_data,last_acquisition = self.queue_container.data_in_queue.get()
                    measurement_data = acquisition_data[self.measurement_channels]
                    output_data = acquisition_data[self.output_channels]
                    self.queue_container.gui_update_queue.put((self.environment_name,('time_data',(measurement_data,output_data))))
                self.shutdown()
                return
        self.queue_container.environment_command_queue.put(self.environment_name,(GlobalCommands.START_ENVIRONMENT,None))
            
    def output(self,write_data,last_signal=False):
        """Puts data to the data_out_queue and handles test level changes
        
        This function keeps track of the environment test level and scales the
        output signals accordingly prior to placing them into the data_out_queue.
        This function also handles the ramping between two test levels.

        Parameters
        ----------
        write_data : np.ndarray
            A numpy array containing the signals to be written.
            
        last_signal :
            Specifies if the signal being written is the last signal that will
            be generated due to the signal generation shutting down.  This is
            passed to the output task to tell it that there will be no more
            signals from this environment until it is restarted. (Default value
            = False)
        """
        # Perform the output transformation if necessary
        # Compute the test_level scaling for this dataset
        if self.test_level_change == 0.0:
            test_level = self.current_test_level
            self.log('Test Level at {:}'.format(test_level))
        else:
            test_level = self.current_test_level + (np.arange(write_data.shape[-1])+1)*self.test_level_change
            # Compute distance in steps from the target test_level and find where it is near the target
            full_level_index = np.nonzero(abs(test_level - self.test_level_target)/abs(self.test_level_change) < test_level_threshold)[0]
            # Check if any are
            if len(full_level_index) > 0:
                # If so, set all test_levels after that one to the target test_level
                test_level[full_level_index[0]+1:] = self.test_level_target
                # And update that our current test_level is now the target test_level
                self.current_test_level = self.test_level_target
                self.test_level_change = 0.0
            else:
                # Otherwise, our current test_level is the last entry in the test_level scaling
                self.current_test_level = test_level[-1]
            self.log('Test level from {:} to {:}'.format(test_level[0],test_level[-1]))
        # Write the test level-scaled data to the task
        self.log('Sending data to data_out queue')
        self.queue_container.data_out_queue.put((copy.deepcopy(write_data*test_level),last_signal))

    def stop_environment(self,data):
        """Stops the environment by setting the test level to zero.

        Parameters
        ----------
        data : Ignored
            This parameter is not used by the function but is required for the
            ``command_map`` calling signature.

        """
        self.adjust_test_level(0.0)

    def adjust_test_level(self,data):
        """Adjusts the test level of the signal

        Parameters
        ----------
        data : 
            New target test level

        """
        self.test_level_target = data
        self.test_level_change = (self.test_level_target - self.current_test_level)/self.environment_parameters.cancel_rampdown_samples
        if self.test_level_change != 0.0:
            self.log('Changed test level to {:} from {:}, {:} change per sample'.format(
                self.test_level_target,self.current_test_level,self.test_level_change))

    def shutdown(self):
        """Performs final cleanup operations when the system has shut down
        
        This function is called when the environment has been instructed
        to shut down and the last acquisition data has been received.  The signal generation
        is the first process in the Random Vibration environment to stop when
        shutdown is called, so it notifies the environment process to stop the
        acquisition and analysis tasks because it is no longer generating signals
        
        """
        self.log('Shutting Down Time History Generation')
        self.queue_container.environment_command_queue.flush(self.environment_name)
        # Enable the volume controls
        self.queue_container.gui_update_queue.put((self.environment_name,('enable','test_level_selector')))
        self.queue_container.gui_update_queue.put((self.environment_name,('enable','repeat_signal_checkbox')))
        self.queue_container.gui_update_queue.put((self.environment_name,('enable','start_test_button')))
        self.queue_container.gui_update_queue.put((self.environment_name,('disable','stop_test_button')))
        self.startup = True

def time_process(environment_name : str,
                 input_queue : VerboseMessageQueue,
                 gui_update_queue : Queue,
                 controller_communication_queue : VerboseMessageQueue,
                 log_file_queue : Queue,
                 data_in_queue : Queue,
                 data_out_queue : Queue,
                 acquisition_active : mp.Value,
                 output_active : mp.Value):
    """Time signal generation environment process function called by multiprocessing
    
    This function defines the environment process that
    gets run by the multiprocessing module when it creates a new process.  It
    creates a TimeEnviornment object and runs it.

    Parameters
    ----------
    environment_name : str :
        Name of the environment
    input_queue : VerboseMessageQueue :
        Queue containing instructions for the environment
    gui_update_queue : Queue :
        Queue where GUI updates are put
    controller_communication_queue : Queue :
        Queue for global communications with the controller
    log_file_queue : Queue :
        Queue for writing log file messages
    data_in_queue : Queue :
        Queue from which data will be read by the environment
    data_out_queue : Queue :
        Queue to which data will be written that will be output by the hardware.

    """
    
    
    # Create vibration queues
    queue_container = TimeQueues(input_queue,
                                 gui_update_queue,
                                 controller_communication_queue,
                                 data_in_queue,
                                 data_out_queue,
                                 log_file_queue)
    
    process_class = TimeEnvironment(
            environment_name,
            queue_container,
            acquisition_active,
            output_active)
    process_class.run()
    
